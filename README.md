# Eng. [Mohamed Hammad's](https://www.linkedin.com/in/mohamed-hammad-a720a622/) Posts

## Eng. Hammad Career Shift

1- [Post 1](https://www.facebook.com/mohamed.hamedhammad/posts/5334372769968563)

<details>

<summary> حيث ان كتير بلاقي ...</summary>

<p>اعيد نشره ربما افادا احدا

#كاريير*شيفت*حماد #مسلسل_١

حيث ان كتير بلاقي في التعليقات زملاء عاوزين يعرفوا قصه الكاريير شيفت من مدني الي هندسة البرمجيات فهكتب في الموضوع بس القصه طويله وانا مش عارف اذا كانت مفيده ولا لأ لكن استجابه للطلب هكتب و هستمر في الكتابه لانها فعلا مش هينفع تخلص في بوست.

انا هبدا من ستة 1994 لان اللي قبلها كانت محاولات طفوليه يعني مش هتفيدك.

قصه الاهتمام الحقيقي بالبرمجيات بدات بسبب موضوعين درستهم الاول هوطريقه لتحليل الاجهادات في المنشات و اسمها Finite Element و التانيه كانت ادارة المشاريع و اللي دفعتني لدراسة Operations Research.

الموضوعين في الهندسه المدنيه كانوا اشاره واضحه لي ان البرمجيات دي حاجه مهمة ومن غيرها كتير من النظريات هتفضل نظريات من غير تطبيق.

محاوله كتابه اي برنامج علشان احل بيه اي مساله في احد هذين العلمين كانت تحدي كبير و اللي كنت اعرفه عن البرمجه حتي هذه اللحظه كان هيخليني اكتب كود سباجتي بالغ السوء.

لكن انا مكنتش عارف ان دا اسباجتي و كنت بجتهد علي قد عقلي. استخدمت Turbo Pascal و مكنتش العقبه في اللغه. العقبه كانت اني مش متعلم يعني ايه تصميم وبحاول افكر بالكود يعني بالعافيه.

كنت بقدر في الاخر انفذ اللي انا عاوزه لكن عمر اي مشروع عملته علشان اتعلم و افهم Finite Element او Operations Research كان قصير و كنت لو حاولت اكمل علي اي شئ كان بيعك جامد.

كنت بستخدم الباسكال بشكل Procedural جدا برغم انها كانت بتدعم بعض خصائص ال OOP و دي كانت علي ما اذكر Version 6.

دا كله دفعني اشوف انا بعمل ايه غلط. بدات اشوف المجلات اللي بتتكلم عن السوفتوير ولقيتها بتتكلم عن OOP وازاي انه مهم.

ودي كانت بدايه القصه الحقيقيه. عرفت اني محتاج اتعلم و افهم العلم قبل اي شئ.

و البداية كانت OOP.

الي حلقه قادمه.</p>

</details>

2- [Post 2](https://www.facebook.com/mohamed.hamedhammad/posts/5334374669968373)

<details>

<summary> بعد ادراكي لأهمية تعلم ال OOP ...</summary>

<p>

اعيد نشره ربما افاد احدا

#كاريير*شيفت*حماد #مسلسل_٢

بعد ادراكي لأهمية تعلم ال OOP جبت كتاب بيتكلم عن ال باسكال و بيتكلم كويس في OOP لاني كنت بعرف باسكال لكن مش فاهم الكونسبتس كويس فقررت اكمل باسكال لكن اتعلم الكونسبتس بقي.

اخدت شهور بحاول افهم OOP كويس و علشان اتأكد من الفهم اخدت التطبيقات اللي كنت كتبتها سابقا بكود سئ جدا يكاد يكون Procedural و بقيت اعيد بنائها بعد عمل تصميم كويس باستعمال OOP ، النتيجة كانت كويسة جدا، و في الوقت دا كنت بحتاج استعمال مع مصفوفات حجمها كبير جدا لأن هو دا اساس نظرية Finite Element و دا وجه نظري لحاجتين، ازاي استخدم الذاكرة اللي كانت قليلة جدا في الأجهزة في ذلك الوقت و عمليات التخزين الجزاء من المصفوفه و استرجعها، طبعا ناهيك عن الأداء الهباب لاني مكنتش بفكر في الأداء خالص و لا أعرفه، و هنا بدأت مرحلة تانية من حياتي.

حسيت اني بتعلم حته بحته و كل متحصلي مصيبه ادور علي الحل، و كمان كنت بدأت افكر اني هكمل في البرمجه، و لازم اتعلم كويس، بدأت اذاكر خوارزميات و قواعد بيانات، كتاب قواعد البيانات اللي جبته اظن كان اسمه Database Concepts، كان بيتكلم عن RDBMS و في نهايته اتكلم عن قواعد البيانات الموزعة علي خفيف كده، و دا وجهني ان لازم افهم أنظمة تشغيل حتي لو مش هبني أنظمة تشغيل، لأن مفاهيم كتير كنت بتكعبل فيها بسبب انعدام العلم دا عندي.

و عرفت ان الطريق هو خوارزميات و قواعد بيانات و أنظمة تشغيل.

و كنت بذاكر التلاته مع بعض و بلتمس من كل علم فهم للآخر، يعني بحاول ادور علي اتصالهم ببعض و دي حاجة اتعلمته من دراستي للهندسة المدنية و هي أن اتصال العلوم هو اللي بيفرق واحد عن التاني.

حبيت قواعد البيانات و علشان امشي ايدي فيها اتعلمت Foxpro و كنت بعمل بيها برامج مع بعض الأصدقاء و و دي كانت custom solutions بنعملها لشركات صغيرة.

بدأت بقي أسقط الكلام اللي اتعلمته عن قواعد البيانات علي Foxpro و هنا اكتشفت ان ال Foxpro دي مش هي الداتا بيز اللي قريت عليها في الكتاب من حيث تطبيقها للمفاهيم لكن لازم اتعلم Engine يكون فعلا كويس و ثابت و قادر علي التعامل مع داتا كتير و هنا بدأت رحلة مع Oracle و اتعلمته و اشتغلت بيها عشر سنين و اشتغلت اوراكل فورمز كمان.

في الفترة دي اتعلمت C++ و جافا و دوت نت، و هنا بقي عندي كلام كتير،

الحلقة الجاية.

</p>

</details>

3- [Post 3](https://www.facebook.com/mohamed.hamedhammad/posts/5334376326634874)

<details>

<summary> في الاتنين بوست اللي فاتوا انا ...</summary>

<p>

اعيد نشره ربما افاد احدا

#كاريير*شيفت*حماد #مسلسل_3

في الاتنين بوست اللي فاتوا انا غطيت الفترة من 1994 حتي 1998 و اللي كنت فيها مهتم بال OOP و خوارزميات و قواعد بيانات وانظمة تشغيل.

بداية من 1998 كنت شغال اوراكل و شوية وب علي خفيف. الفترة دي بدات اهتمجدا بفهم التكنولوجي و كمان اتعلمت Networking وفهما Routing and Switching و اتعلمت دا علي Cisco , IBM.

في الوقت دا IBM كانت بتعمل راوترز.

عاوز اتكلم هنا عن الطريقه اللي كنت بتعلم بيها التكنولوجي. كنت بدور ورا كل حاجه يعني مثلا اجيب ادوات تراقب ال TCP و كانت مستواها متواضع جدا لكن كنت بقعد ساعات طويله اتعلم ال TCP شغال ازاي واقارن اللي بتعلمه باللي بشوفه من الادوات دي وقريت كتاب عن برمجهNetwork باستعمال C++.

و عملت نفس الشئ مع اوراكل. بقيت اقرا كتب ال Tuning بتاعه اوراكل و اقعد اشوف ال Query ممكن تتكتب بكام طريقه واقارنهم.

الفتره دي من حياتي و اللي بدات سنه 98 كنت فيها ادركت ان المهندس الي له قيمه مش هو اللي بيكتب الكود لا دا المهندس اللي فاهم ايه اللي بيعمله الكود.

و كمان اتعلمت برمجه Autocad باستعمال لغه اسمها Autolisp.

ودا بقي كان حدث تاريخي. لان لغه Autolisp دي لغه Functional وفيها مفاهيم كانت جديده علي زي Immutability و Pipelines.

الحقيقه كانت مزعجه جدا لكن الاستمرار معاها خلاني اشوف قيمتها جدا.و الدنيا نورت في اتجاه حتي زمايلي اللي كانوا دارسين برمجيات مكنوش شايفينه. بدات اشوف لغات البرمجه من منظور انهم بيعبروا عن فلسفه.

فلسفه ال OOP كانت حمايه ال Stateعن طريق Encapsulation وفلسفه FP كانت الغاء ال State اوتقليلها الي حدها الاصلي عن طريق Immutability and Pipelines.

و رجعت تاني اشوف اللغات والكود و قررت اتعلم اللغات من تحت خالص واشوف اساسا يعني ايه لغه برمجه و يعني ايه Compiler.

و بدات اتعلم Compilers و ادخل في مواضيع زي Automata و اذاكر Discrete Math علشان تساعدني.

يعني تقدر تقول ان من 1998 و حتي 2002 كانت من اعنف فترات حياتي .كنت مش بقبل اي حاجه في التكنولوجي من غير الساينس الي وراها لدرجه اني كتبت Parser لل SQL محدود طبعا وعملت Database باستعمل Random Access File علشان افهم ال Physical layer بتاعه الداتابيز.

ودول كانوا اربع سنين من 98 حتي 2002 انا كنت بشتغل وبذاكر وتقريبا مش بنام و بدات احس بتاثير دا علي مستوايا و اختلف تقييمي للناس اللي بتعامل معاهم لاني بدات احس انهم ممكن يقولوا كلام مبني علي تجربه مش مبني علي علم و بدات رحله مرعبه. شاكك في اي معلومه مصدرها انسان مش كتاب و استمر معايا الاحساس دا حتي الان.

لاني مش عارف اللي بيتكلم دا اتعلم ازاي ودا عقد حياتي شويه لاني مبقتش قادر استفيد من اي حد بيشتغل معايا و بحاول ادور علي كل شئ بنفسي في كتب ومراجع. طبعا دا كان متعب له كان له جانب مضئ شفت تاثيره علي السنوات التاليه كما سيجئ ذكره

الي حلقه قادمه.

</p>

</details>

4- [Post 4](https://www.facebook.com/mohamed.hamedhammad/posts/5334378616634645)

<details>

<summary> انا وصلت مع حضرتك لسنه 2002. ...</summary>

<p>

اعيدنشره ربما افاد احدا

#كاريير*شيفت*حماد #مسلسل_4

انا وصلت مع حضرتك لسنه 2002. عند الوقت دا كان عندي معلومات كويسه جدا في مواضيع كتير ومن اكترها الداتابيز و كنت بشتغل اوركل بشكل رئيسي و بقيت فاهمها كويس لدرجه اني بقيت كمان شايف فين اوحه النقص فيها.

في الفتره دي سرعتي في القرايه زادت جدا و بقي عادي اني اشتغل في اكتر من موضوع في نفس الوقت. يعني كنت بذاكر وب و بذاكر باك اند و مع بعض شغال في ميلون حاجه.

علي سطح الاهتمام عندي كانت الاستخدامات المتقدمه لقواعد البيانات بالغة الضخامه اللي فيها مليارات الريكوردز وازاي نطلع منها تقارير تحليليه عنيفه بدون التاثير علي الاداء بتاعها.

و كانت هناك تكنيكس شائعه في ذلك الوقت لعمل Data warehouse و استخدامه لهذا الغرض.

الادوات اللي كانت متاحه من اوراكل قي هذا الوقت كان مصدرها شركه اظن كان اسمها Siebel و كانت ادوات مش كويسه اوي و الا Integration بينها وبين الاوراكل كان متعب و مش مستقر كفايه و اداؤه برضه مش حلو.

و علشان افهم كويس قريت مجموعه كتب عملها عالم كبير اسمه Ralph Kimball و دا كان بيتكلم عن تصميم ال Data Warehouse وعن مفهوم اسمه Multi Dimensional Database و ازاي ننقل الداتا و نوصلها لصورة تبقي مناسبه جدا لل Reporting و ازي تبقي سريعه باستعمال نوع من Index اسمه Bitmap Index.

قريت كتب الراجل و فهمت ولقيت العلم دا والكونسبت دا مش متحقق في منتجات اوراكل كويس والمذهل بقي اني لقيت SQL 2000 محقق شويه من المطلوب ولقيت عندهم لغه بتفهم Multi Dimensional Database و اسم اللغه MDX وميكروسوفت اللي عملاها.

و بدات اشوف ميكروسوفت وانها شركه بتقدم Innovation كويس و بدات اذاكر MS SQL و كمان اتعلم BI بتاعه.

و قضيت اسابيع اتعلم ال MDX كويس و اللي استفدته منها كان اكبر من مجرد انها Query Language لا دا كان توجه في تصميم اللغه و ازاي ان اللغه تبقي Metadata driven يعني لغه بتعمل استكشاف لل Data Structure اللي هتشتغل عليه. الفهم دا ساعدني بعدها احل مشاكل في مسائل تانيه(بس دي قصه تستحق بوست لوحدها)

و بدات بقي احب ميكروسوفت و اللي كان بيقول عليهم انهم اي كلام كنت بعرف انه جاهل وبغبغان.

و بدات رحلتي معاهم.

الي حلقه قادمه.

</p>

</details>

4- [Post 5](https://www.facebook.com/mohamed.hamedhammad/posts/5334380406634466)

<details>

<summary> بدات الاهتمام بمنتجات ميكروسوفت ...</summary>

<p>

اعيد نشره ربماافاد احدا

#كاريير*شيفت*حماد #مسلسل_5 و الاخيرة

بدات الاهتمام بمنتجات ميكروسوفت و دا تزامن من بداية الدوت نت و الاعصار اللي حصل سنه 2005 في مكانين. اولا اطلاق Asp.Net و كمان SQL 2005

اللي حصل في الوب انهم عملوا تكنولوجي يخليك تشتغل من غير متشغل بالك ان Http is statless و حققوا دا عنطريق اختراع اسمه Viewstate.

ذاكرا التكنولوجي ودخلت في عمق بناء ال Server Controls و قضيت ايام علشان افهم ال Asp Pipeline و ازاي بيعمل Render و الحقيقه دا كان طفره في ذلك الوقت واستمتعنا بال WebForms كتير وطبعا اتعلمنا بالطريق الصعب ان ViewState هو صديق لدود يعني بيوفر وقت في التطوير بس بتدفع تمنه في الاداء.

بقيت بحب ال Visual Studio و شتان بينه و بين ادوات اوراكل بالغة القبح والغباء.

و علي الناجيه التانيه كان صدور SQL 2005 ودتا كان Milestone في حياتي لسببين.

الاول ان ادوات ال BI فيه كانت ثورةكبيرة ومن اهمها SSIS اللي ممكن بيها تبني Transformation للداتا و تنقلها الي Warehouse و كمان تعمل Cube Processing هايل. دا مستوي اوراكل وصلت لحاجه قريبنه منه سنه 2007.

انشغلت واهتميت جد بال BI بتاع ال SQL و اتعلمته كويس و لقيت فيه تطبيق واضح و رائع علي كتب الخواجه Ralph Kimbell وكنت سعيد جدا ان فيه تكنولوجي بيحقق اليانس اللي قريته.

و مع ال SQL 2005 ميكروسوفت اصدرت معاه Data Mining Toolkit.

ودي كانت بدايو ظهور منتجات تخص ML في ميكرسووفت.

قبل التاريخ دا كان المهتمين بال ML هم قله من المختصينومحدش بيسمع ايمه ولا بيفكر فيه يعني.

بظهوره في التكنولوجي ستاك بتاع ميكروسوفت وفي منتج رئيسي زي SQL حسيت اندا توجه مهم عندهم وانا عندي ثقه انهم شليفين المستقبل.

كنت عاوز اسبق في المساحه دي وبرغم ان مكنش فيه مطالب من البيزنس علي مواضيع ML ولا Neural Network في ذلك الوقت بشكل كبير الا اني بدات اذاكر العلوم دي وعلشان اتعلم كويس مخدتش قرارات ايه منها مهم علشان اركز عليه. جبت كتاب بيتكلم عن Intelligent Systems عموما وبدات اشوفه بيقول ايه علشان اشوف الموضوع من فوق شويه.

كان بيتكلم في حاجات كتير مرورا بال Neural Network Fuzzy Logic, Genetic Algorithm , Expert Systems وغيرها.

الكتاب كان فيه شوية رياضه خفيفه فرجعت اذاكر Linear Algebra لاني كنت محتاجه و شوية Calculus.

وقريته وبقيت اجرب اكتب كود يعمل كل مودل اتعلمته علشان اتاكد اني فهمت كويس.

و الراجل اللي مالف الكتاب كان في احدفصول الكتاب بيتكلم عن نماذج هجينه Hybrid Systems و بدل ميعمل تدريب لل Neural Network باستعمال Back Propagation قدر يحل نفس المساله بانها حولها لقضيه Optimization وحلها باستعمال Genetic Algorithm وقدم باب كمان بيتكلم عن Genetic Programming وقال فيه ازاي ممكن تبني Expression معقد تحاكي بيه سلوك منحني باستعمل Evolution و لقيت كلمه Evolutionary Computing بتتكرر ومع كل تكرار لها بشوف معجزة تطير العقل.

وعنها و رحت جايب كتاب بيتكلم عن Computational Intelligence وجزء كبير منه عن Evolutionary Computing.

و كان كتاب صعب و التهمت الكتاب و كنت بعمل الامثله بال Matlab و بكتبها علشان افهم كويس.

ومن التاريخ دا و انا بذاكر غي كل مساحات ال AI وحتي هذه اللحظه.

الرحله مستمره ومريت فيها بكل شئ من اول الجافاسكريبت و مراقبه الترافيك بتاع الوب علشان افهم سلوك ال AJAX مرورا بقواعد البيانات علي اختلافها و ال BI بكل ما فيه وفلسفات لغات البرمجه و ال AI بمختلف افرعه.

وعلي الدرب سائرون

يا ريت بقي تكون عرفت ليه بقولك متحبسش نفسك في حته وتحجر علي عقلك. العقل البشري مالوش اخر.

لوكانت هذه السلسله افادتك بشئ فرجاء تنشر فكر التنوع في التعلم فيمن حولك و تشجع غيرك يتعلم.

و شكرا علي من تحمل قراءة الخمس حلقات.

</p>

</details>

## [Software Tester](https://www.facebook.com/mohamed.hamedhammad/posts/5334246833314490)

<details>

<summary>

امتي يبدا دور السوفتوير تيستر ؟

</summary>

<p>

امتي يبدا دور السوفتوير تيستر ؟

انا عارف ان دا شكله سؤال ساذج جدا. لكن طول بالك علي.v

دور السوفتوير تيستر يبدا لما الديفيلوبر يخلص التاسك و يجربها وميلقيش فيها مشاكل.

متخلصش التاسك وتبقي عارف انها مليانه مشاكل وتديها للتيستر وانت متاكد من اللي فيها.لان كده انت معملتش شغلك.

شغل التيستر يبدا لما الديفيلوبر يعتقد ان شغله مفيش فيه مشكله وعندها يبدا التيستنج.

مفيش حاجه اسمها انك تكنب عشرين سطركود يطلع منهم عشره Bugs.

النكت الي بنشوفها كل يوم علي السوشيال ميديا مالهاش غير معني واحد. الناس مش عارفه واجباتها. و كل واحد بيكتب كود نبش فراخ فاهم ان عادي يطلع في شغله بتاع اسبوع تلاتين Bug.

لا دا مش عادي.دا اسمه اهمال وقله احترام للعمل و للاخرين.

</p>

</details>

## [AI](https://www.facebook.com/story.php?story_fbid=5360290700710103&id=100001876777351&_rdr)

<details>

<summary> لو حضرتك بتتعلم AI ... </summary>

<p>

لوحضرتك بتتعلم AI او اي حاجه تخصه اوحتي بتشتغل في هذه المساحه خليك معايا دقيقتين كده.

هقولك علي مشاهده بلاقيها اثناء تعلم الزملاء في هذه المساحه. تلاقيه غطسان في جزء محدد وبيتعلمه. يعني مثلا بيتعلم Neural Network تمهيدا لانه يتعلم Deep Learning او ماسك في خناق ال Decision Tree لانه يتعلم Machine Learning وكمان بلاقي كورسات كتير بتسلك هذا السلوك. يعني ماسكين العلم من "ديله" مش من راسه.(لا مؤاخذه علي التعبير).

شوف يا مولانا. ال AI دا وكل ما فيه وما تحته محتاجك تشوف حاجتين(هم اكتر شويه لكن هتكلم عن ابرزهم يعني). الاولانيه ان عندك داتا عاوز تعمل نظام يفهم من الداتا و يبدا يدينا سلوك يعبر عما في داخل الداتا. التانيه ان عندك مساله محتاج لها حل ومحتاج تبحث عن الحل لكن فراغ البحث بالغ الضخامه ومحتاج تلاقي حل في زمن معقول.

دراسه العلم دا بقي بانك تبدا تخبط نافوخك في نماذج محدده زي Linear Regression ولا Decision Tree بتخليك شايف حته من حته من حته من الفيل. يعني واقف جنب رجل الفيل فلو سالتك ايه هو الفيل؟ هتقولي دا عمود دائري زي عمود النور. لانك ببساطه واقف جنب رجل الفيل.

فهمت ؟

امال اعمل ايه بقي ؟

فيه كتب عملها ناس مخها منور و زي الفل. دي الكتاب اللي انا حاطط صورته هنا.

الراجل دا مسك العلم بتاع AI و هتلاقيه بيقدمه باعتبار انه حاجه من اتنين Learning Problem ودي اساسها داتا و بيتكلم بقي عن تمثيل الداتا وادخالها للمساله وان الداتا دي هي Knowledge ولها طرق للتمثيل حسب كونها Deterministic او non Deterministic و التعامل مع كل واحده ازاي. و بيحكي بقي في Knowledge Representation. و بعدميعلمك ازاي تمثل ال Knowledge يبدا بقي يعلمك ازاي النموذج يتعلم منها وهنا يجي دور Learning.الحاجه التانيه اللي الراجل بيقولها هي الوجه التاني لل AI و هو انه Search problem و ايه هي طرق بناء Search Space وحله لايجاد Optimal Solution في ضوء المعطيات والشروط.

يعني ال AI متقسم في الكتاب الي الحاجتين اللي قلتهملك.ذكاء مصدره التعلم من الداتا ذكاء مصدره البحث عن الحل في فراغ الحل الذي قد يكون ضخم جدا وطرق التغلب علي هذه الضخامه.

يا باشمهندس. ارجوك ابدا العلم من راسه مش من ديله.

انا لما بدات اتعلم القصه دي سنه 2005 لفيت في كتب كتير اوي علشان اكون الصوره الكليه للعلم. و عاوز اوفر عليك العذاب. اقرا الكتاب دا.

دا كتاب ضخم. اعتبره هدف ياخد منك سنه و لا اتنين.حتي لو بتتعلم في اتجاه معين زي ال Deep Learning. كمل في اتجاهك واقرا الكتاب دا علي التوازي.

ليه ؟ هتكتشف بعد قرايته ان فيه مسائل كتير حلها محتاج فهم للصوره الكليه ومعالجه عبر اكتر من نموذج و هتلاقي اللي انت اتعلمته من ML او DL اوي Reinforcement Learning بيتكامل علشان تحل مسائل حقيقيه.

لما تقرا الكتاب هتلاقي نفسك شايف ال AI من راسه و شايف التفاصيل تحتك و تقدر تمد ايدك تجيبها وقت الحاجه.

انا بقولك الكلام دا بناء علي خبره عمليه مع ناس كتير بمستويات مختلفه و دي من الانترفيوز. يعني دي استنتاجات حقيقيه.

دراسه العلم دا بقي بانك تبدا تخبط نافوخك في نماذج محدده زي Linear Regression ولا Decision Tree بتخليك شايف حته من حته من حته من الفيل. يعني واقف جنب رجل الفيل فلو سالتك ايه هو الفيل؟ هتقولي دا عمود دائري زي عمود النور. لانك ببساطه واقف جنب رجل الفيل.

يعني بيحاول يلوي دراع المساله علشان يدخلها في حيز الالجوريزم اللي هوعارفه. تلاقي اللي اتعلم Neural Network و كمل Deep Learning عاوز يبني نموذج و يحل بيه. تقوله الداتا اللي عندي مش كتير. اعمل ايه ؟

يقف وميعرفش يتصرف لانه ببساطه ميعرفش غير DL و مشافش مثلا ان فيه حاجه اسمها Probabilistic Models تقدر تبني بيها نماذج بناء علي Domain Knowledge بيسموها Prior و تدرب النموذج عليها لومعندكش داتا كتير. او تستخدم تكنيكس تولد بيها داتا من نماذج احصائيه و تحط عليها Noise وبعدين تدخل بقي بيها علي DL.

يعني الخلاصه المشكله بتكون ان الناس اتعلمت حته من الفيل و مش شايفين غير رجل الفيل و بيقولك دا عمود نور.

فهمت قصدي ؟

الحمدلله. استمر فيما تتعلم لكن اقرا الكتاب دا علي التوازي لوكنت بتتعلم AI اوبتشتغل AI وعاوزتبني فيه كاريير كويس.

لو لقيت البوست مفيد اعمله شير. يمكن تنقذ غيرك من اللي واقفين جنب رجل الفيل وبيقولوا عليه عمود نور.

<p>

</details>

## .Net

[.Net group](https://m.facebook.com/story.php?story_fbid=5251717044900803&id=100001876777351)

1- [Post link](https://m.facebook.com/story.php?story_fbid=5345089308896909&id=100001876777351)

<details>

<summary>

البوست دا هقولك فيه علي كتب

</summary>

<p>

البوست دا هقولك فيه علي كتب في الدوت نت تساعدك تفهم كويس استخدمات و سلوك الفريمورك وازاي تستخدم اللغه كويس.

دي مش كتب تعلمك ازاي تعمل For Loop. لا خالص و الله.دي كتب موجهه للمهندسين اللي بيشتغلوا دوت نت لكن عاوز يفهمها احسن ويستخدمها احسن.

هتلاقي اللغه بتقدم حلول ذكيه و سهله تستبدل بيها كود كتير كنت بتكتبه ولومعرفتهاش هتفضل تكتب نفس الكود مع ان الفريم اتطور.

C# 9.0 in a Nutshell

C# in Depth

Concurrency in .NET

المهندسين اللي بيقروا كتب من المستوي دا بتلاقيهم بيعرفوا يختاروا ايه يتكتب و امتي وليه في التاسك اللي قدامهم.

هتلاقي كلام عن Reflection و ازاي تستخدمه بحذر علشان تبني انظمه مرنه جدا و ال Dynamic keyword و ازاي تساعدك تعمل المعجزات بتاعه الجافاسكريبت جوه الدوت نت لو محتاجها.دي كتب بتخليك تخرج من الفريمورك كنوز و تعرف منها فين المخاطر بتاعه الحلول الجميله دي لانها مش كتب Syntax و خلاص.

و الناس اللي بتقرا الكتب دي هي اللي بتكبر في القيمه مش بس في السن.

اللي يبدا يقرا يبقي يوالينا بتجاربه ورأيه فيما قرا.

علي الدرب سائرون.

</p>

</details>

## [LINQ](https://m.facebook.com/story.php?story_fbid=5343539002385273&id=100001876777351)

<details>

<summary> انا لاحظت من بعض التعليقات علي فيديوز </summary>

<p>

انا لاحظت من بعض التعليقات علي فيديوز ال FP في اليوتيوب ومن خلال بعض الاسئلة علي لينكدان والفيس بوك ان كتير من الناس مش متخيلين ال LINQ بتشتغل ازاي وعندهم تصور خطا جدا عن الطريقه اللي الكود بتاع ال LINQ بيتنفذ بيه و طبعا دا بيخليهم مش قادرين يعملوا تقييم كويس للاداء علي عكس Imperative Code اللي بيشوفوه بعنيهم وفاهمينه بيعمل ال Looping و ال Processing بتاعه ازاي و قادين يحسبوا ال Complexity بتاعته.

دي مش مساله تخص ال LINQ تحديدا. لا دي مشكله تخص فهم المهندسين لطريقه تنفيذ ال Pipeline في اي لغة برمجه لانه سلوك ال Declarative Code بيخفي عنك الصورة الحقيقيه لل Execution.

دا موضوع تكنولوجي بحت يعني وهوبيخدم ال FP و لو انه ليس جزء منها.

السيشن دي بتتكلم بوضوح عن سلوك ال LINQ و ازاي بتحقق ال Pipeline و ال Execution بتاعها بيمشي ازاي علشان يبقي Optimal و كمان هوريلك كود بيستخدم باترن تخليه بيحاكي نفس السلوك بتاع ال LINQ و بعمل Tracing لل Execution و هتشوف ازاي ان ال LINQ و الكود دا من غير استخدام ال LINQ بيسلكوا نفس السلوك.

دي سيشن في قلب ال LINQ بعمق شديد و ال Pipeline و سلوك ال Compiler في تنفيذ ال LINQ.

هتشوف وتعرف حاجات في الدوتنت وهتعرف ان ال LINQ بيديلك Declarative model بالغ الذكاء و هتشوف دا في ال Execution بعنيك.

سيشن تقيله .ارجو الله انكم تصبروا عليها لانها مفيده جدا في تقييم اداء ال LINQ ومش بس ال LINQ لكن اي Pipeline مشابه في اي لغة و توضيح Computation Complexity بتاعته و دا بالغ الاهمية لما تعتمد عليها في ال FP.

معلومات تقيله شويتين اجتهدت اني اخليها واضحه للجميع, ارجو الله اكون اتوفقت.

حضرتك ممكن تكمل كورس ال FP و تراك ال Declarative كله عادي جدا من غير مشاهده السيشن دي. لكن انصحك تشوفها. بعدها هتفهم حاجات في ال C# و في تحليل سلوك الكود هتفيدك في ال LINQ و في تنميه مهارات تحليل ال Execution عموما.

</p>

</details>

[Video Link](https://www.youtube.com/watch?v=Osa9wSMVgS0&list=PLpbZuj8hP-I6F-Zj1Ay8nQ1rMnmFnlK2f&index=11)

## [Science & Technology](https://m.facebook.com/story.php?story_fbid=5340348566037650&id=100001876777351)

<details>

<summary> ممكن تلاقي هنا رد علي سؤال متعب بتساله لنفسك كتير... </summary>

<p>

ممكن تلاقي هنا رد علي سؤال متعب بتساله لنفسك كتير.

هدوخ نفسي في سلوك التكنولوجي و فهمه مع الساينس ليه ؟

سؤال مهم جدا و لك حق طبعا تسال.الحقيقة مذاكرة نظريات ليس بينها و بين التطبيق رابط واضح ممكن يستهلك وقت و العائد يكون قليل و انا عمري مقلتلك كده،مش هقولك نصايح و وعظ وخلاص.خليك معايا.

هوضحلك كلامي بمثال من كتير جدا عبر عملي و حاله مريت بيها و توضح ازاي كان الفهم مفيد.

عندي سرفس مفروض انها تعمل شغلانه باقصي سرعة ممكنه و معيار نجاحها انها تستخدم ال CPU الي أقصاها.

لاحظنا أثناء الاختبار انها بتستخدم ٨٤٪ من ال CPU فقط.

الكود بيعمل Thread Sync من غير Lock و مكتوب كويس جدا، ليه بقي مش بيستخدم ال CPU للاخر ؟؟

استخدمت Profiling Tool و حللت ال Waiting الي مكوناته و لقيت أن Garbage Collection هو أكبر مسبب لل Thread being in Waiting State.

و عندها افتكرت موضوع كنت قريته عن الميموري و ربطته بكلمتين عن Dotnet، افتكرت ان فيه بارامتر اسمه servergc لو حطيته true تخلي الدوتنت تعمل dedicated Threads بعدد ال Cores و تديها highest priority وقت ال garbage Collection و دا بيقلل ال Thread contention و بيحسن الأداء.(مش عاوز اغطس هنا في الاسباب-مش دا غرض البوست)

المهم، عملت التغيير في البارامتر و جربت و السرفس اشتغلت صاروخ و جابت ٩٧٪ من ال CPU زي منا عاوز.

لو انا مش عارف سلوك الميموري و مش رابط الافكار بتاعة نظام التشغيل مع التكنولوجي كنت هتقول أمرنا لله دا سلوك الدوتنت و خلاص بقي.

تعلم الساينس و فهم التكنولوجي مهم إنما دا مش معناه انك تروح تلف في مواضيع بعيدة عن التطبيق و تذاكر معادلات تفاضلية من الدرجة التامنة و تقولي انا مش بتقدم، لازم تحسن اختيار المواضيع و المعيار هو الساينس اللي بيخدم تكنولوجي مش خيالات في كوكب المريخ.

اللي يحسب الحسابات في الهنا يبات.

</p>

</details>

## [Attention](https://m.facebook.com/story.php?story_fbid=5316351721770668&id=100001876777351)

<details>

<summary> من أربع سنين ناس نشروا بحث عن... </summary>

<p>

من أربع سنين ناس نشروا بحث عن حاجة اسمها Attention و ساعتها كانوا يقصدوا استخدامه مع RNN علشان يديها سلوك اشبه ما يكون بال Selective Memory و دا هيحسن قدرتها و دقتها لان تدريب ال LSTM متعب و بيستهلك وقت، الفكرة دي بقي اتطورت لحاجة اسمها Multi Headed Attention و دا ميعدش امتداد للفكرة الاولي لكن عنده برضه قدرة علي تكوين Context يشوف بيه علاقات ال Tokens ببعضها فيكسبها معني افضل لأنها بقت فاهمه ال Context و تطبيقه في NLP مباشر تماما، تكوين اركتكتشر معتمد عليه كون بقي بلوك بيسموه Transformer و بقاله Implementation في الفريموركس المختلفة Tensorflow, Pytorch, Keras و غيرهم.

استخدام ال Transformers دي انتقل من NLP الي الصور كمان و بدا يبقي وحدةبنائية لاركتكتشرز اكبر و قدرتها اعلي علي فهم المدخلات و عمل Map لها الي أشكال افضل ترفع دقة التدريب جدا.

تخيل كده جملة I walk by the river Bank و جملة I need to go to the bank to get cash، كلمة Bank اتغير معناها بسبب ال Context و ال Transformers بتفهم دا و عمل Stacking لها فوق بعض بخليها تفهم اكتر و اكتر علاقات Dependency بين الكلمات. و الأمور دخلت كمان في درجات اعلي من Abstraction لتحليل الصور لبيان تأثير الحركة بتاعة أجسام و جعل النموذج يعبر عن الفيزياء في سقوط جسم مثلا الي الأرض.

الحتة دي فيها كلام كتير و هعملها بوست لوحدها. النموذج بدا يكون تعبير عن العالم و فيزياء السقوط الحر.

قريبا جدا هنبدأ نلاقي كتب كاملة عن Transformers.

مناهج ال Deep Learning اللي بتدرس في الجامعات محتاجة تتغير سنويا و القائمين علي تدريس لازم يشتغلوا علي نفسهم جامد جدا. و لو انت بتدرس في جامعة مصرية يعني لازم تذاكر من محاضرات بيركلي و لا ستانفورد، يعني حرام عليك نفسك بجد لو معملتش كده.

احنا بقي كمهندسين بنواجه علوم بتتطور بشكل غير مسبوق و لا أعتقد أن فيه ناس بتقابل تحدي زي دا في اي تخصصات او مهن اخري. احنا حرفيا بنجري ورا القطر. لا ينفع تركن و لا حتي تهدي شوية.

البوست طول مني معلش لكن فيه افكار كتير و بسجلها لاني برجع اوضحها بعدين فعاوز ارجع الاقيها

</p>

</details>

## [Algorithms](https://m.facebook.com/story.php?story_fbid=5228129937259514&id=100001876777351)

<details>

<summary> لوحضرتك مدرستش هندسة برمجيات... </summary>

<p>

لوحضرتك مدرستش هندسة برمجيات وعاوز تتعلم هقولك علي اول خطوة.

تتفرج علي السلسه اللي اللينك بتاعها هنا و تقرا كتاب Grokking Algorithms.

و هعملك فيديو قريبا اقولك فيه بعد كده تعمل ايه لان هحتاج احكي شويةحواديت. انما البدايه هي دي. دا بغض النظر ناوي تعمل ايه بعد كده.

المصدرين دول هدفهم انك تعرف ان كتابه البرامج ليست تحويل حل المساله من منطوق اللغه الانجليزيه الي لغة برمجه لكن هي تحويل المساله نفسها الي نموذج يسهل برمجته.

اقرا الجمله اللي فاتت عشر مرات. و لو مش فاهما متخافش لما تتفرج علي البلاي ليست وتقرا الكتاب هتعرف قصدي وهتكون علي الطريق الصح.

</p>

</details>

## [Keep learning](https://m.facebook.com/story.php?story_fbid=5218792461526595&id=100001876777351)

<details>
  
<summary>

انا حاولت اكتب البوست باقل قدر من الحده والانفعال. لكن للاسف برضه لا يزال حاد.

</summary>

<p>

انا حاولت اكتب البوست باقل قدر من الحده والانفعال. لكن للاسف برضه لا يزال حاد.

البوست دا عنوانه "لومش بتتعلم وتستمر في التعلم يبقي ارحم غيرك من معلوماتك اللي انتهت"

ليه ال SQL عنده Operator اسمه Spool ؟

لانه بيلاقي في بعض ال Queries المعقده انه محتاج نواتج وسيطه بشكل مؤقت فبيقوم يخزنها ويكمل عليها.

هو بيعمل كده بنفسه لنفسه. ومفيش داعي تساعده باستخدام Temp Tables.

حضرتك لو متعود تكتب Stored Procedure وتستخدم جواها اكتر من Temp Table فدي في الحقيقه براكتس بالغ السوء.

بدايه بقي اعندك اكتر من Statements متصلين عند الداتا مش ال Execution يعني مبقوش جمله و احده علشان ال Optimizer يتصرف احسن. يعني حضرتك قللت قدرته انه يساعدك.ثانيا وجود ال Temp Table بيخلي ال Stored Procedure يعمل Re Compilation لانه بيشعر ان ال Schema اتغيرت. الثالثه ان الكود بتاعك في ال Stored Procedure بقي مغارة ضلمه و محدش بقي قادر يفهم الغرض منه غيرك.

يا ناس. حاول تكتب اللوجيك بتاع Fetch في جمله SQL و اعمل Index سليم و سيب ال SQL ياخد قراراته وهو شايف المسار علي بعضه.

يا ناس ال Temp Table دا كان شائع جدامن عشرين سنه لان قدرات ال Optimizer كانت متواضعه الي حد بعيد و ال Spool Operator مكنتش ذكيه كفايه و دلوقتي في منها انواع واشكال بتساعدك من غير متحس وبتتدخل لما تلاقي Redundant Sets محتاجه تعاملها كداتا وسيطه.

يا اسيادنا. الدنيا اتغيرت اوي عن SQL 2000 كفايه Temp Table ارجوكم و بطلوا تعلموا المهندسين الصغيرين التكنيكس اللي استخدمتوها من عشرين سنه.

انا هنا بكلم الناس الكبيرة اللي بتنقل للاصغر منها تكنيكس متواضعة المستوي لانهم مش بيطوروا نفسهم.

ال Optimizer بقي ذكي جدا جدا جدا.

لو مش مصدقني اقرا كتب Grant Fritchey. دا من اكتر عباد الله فهما لل Execution Plan.

</p>

</details>

## [Messaging Patterns for .Net Developers](https://m.facebook.com/story.php?story_fbid=5206858189386689&id=100001876777351)

يا شباب.

الفيديو دا فيه معلومات عن عمل Messaging باستعمال دوت نت تكنولوجي.

فيها معلومات هايله هايله هايله.

اوعي يفوتك.

[On .NET Live - Messaging Patterns for .NET Developers](https://www.youtube.com/watch?v=ef1DK76rseM)

## Database Posts

<details>
<summary>
كتابين دا هينقلوك الي فهم كويس لمختلف المفاهيم الخاصه...
</summary>
<p>
لو عندك معلومات اوليه عن قواعد البيانات واقصد بيها Graduate Level (ايوه دي اسمها اوليه) الكتابين دا هينقلوك الي فهم كويس لمختلف المفاهيم الخاصه بقواعد البيانات.

الكتاب الاول بيروح اكتر في سكه Horizontal Scalability و لهذا السبب هتلاقيه مش بيتكلم كتير عن Relational Model (انا عارف ان فيه بعض النماذج بتحقق دا في Relational بس دا مش حيز الحديث يعني)انما الكتاب التاني متخصص في ال Relational و برغم كونه موجه لل SQL Server الا انه بيقول المفاهيم كويس اوي و هتقدر تنقل منه الي التكنولوجي بتاع ال Engine اللي شغال بيه ودا له سبب ان ال SQL بيدعم نموذجين من ال Concurrency اللي هم Locking and Versioning و دا السبب انك لو قريته ممكن تروح منه الي Oracle او MySQL اوغيرها. و انا اخترته لانه اكتر كتاب بيربط مفاهيم بتطبيق في المساحه دي.

الكتابين مكملين لبعض.

بعدهم تقدر تتعلم اللي يخص التكنولوجي اللي بتستخدمه في حياتك اليوميه وهنلاقي ال Documentation بتاعه التكنولوجي اكتسبت معني جديد.

لما تقراهم وترجع تقرا في التكنولوجي بتاع قاعدة البيانات اللي انت شغال بيها هتعرف معني كلامي. متستغربش يعني.دول استثمار لحياتك هتغرف قيمتهم لما تشتغل في انظمه فيها داتا كتير و عددمستخدمين كبير ومتزامن.

انا قريت كتب كتير عن مواضيع تخص اداء قواعدالبيانات وتصميم ال Engine و ال Tradeoff المرتبط بكل قرار في التصميم عبر سنين و الكتب دي صدرت مؤخرا وحقيقي هي افضل ما قرات و كل الغوامض اللي عانيت في فهمها عبر سنين لقيتها مشروحه هنا بسهوله و وضوح. يعني يا بختك انت كده بتبدا من حيث انتهي الاخرون و طلع عينهم.

الكتابين دول بيعوضوا النقص المروع في تدريس قواعد البيانات في الجامعات بتاعتنا. فعلا يعني دول العلاج.

شير البوست من فضلك لانه ممكن يختصر علي ناس كتير عذاب و لف ودوران.

</p>
</details>

<details>
<summary>
اقرا بالراحه كده وباذن الله هتلاقي كلمتين فيهم فايدة
</summary>
<p>
اقرا بالراحه كده وباذن الله هتلاقي كلمتين فيهم فايده.

البوست دا للناس اللي بتشتغل في قواعد بيانات كبيرة وبتكتب Queries معقدة اوي.

كل قواعد البيانات سواء كانت SQL او NoSQL بتحاول توفر خاصية مهمة اوي اسمها Push Down.

ايه دي و دا يهمني في ايه ؟

لما حضرتك بتبعت Query للداتابيز بيكون من الاهمية بمكان ان عملية Filtration تتم باستخدام ال Index يعني الداتابيز تفلتر الداتا اثناء القراءة و متجيبش الداتا كلها وتفلترها في الميموري. و دا مهم اوي ونجاخ الداتابيز انها تعمل كده معناه انها بتبعت جملة ال Where الي ال Index يعني لحد متوصل لل IO و علشان كده بيسموها Push Down.

كويس اوي . وانا مالي بقي ؟

احيانا لما بتكون ال Query معقده جامد وبخاصة لو فيها Grouping و Filtration و عدد ال Joins كبير ال Optimizer مش بينجح يعمل Push Down وتلاقي عملية القراءة بتعمل IO كبير جدا و طبعا بتستهلك ذاكرة كبيرة ودا بيكون واضح في عمليات Scan وعدم قدرة ال Optimizer انه يعمل Seek باستخدام Where لان تداخل ال Groups مع Where مع Joins المعقدة منعه من ال Push Down.

دا مش بيحصل كتير بفضل ذكاء ال Optimizer لكن برضه لسه بيحصل.

طيب لو دا حصل اعمل ايه ؟

هقولك حيلة قوية. عارف ال Table Valued Function دي انك تعمل Function بترجع Tabular و تكون بتاخد البارامترز اللي انت عاوز تفلتر عليها واعمل بقي ال Group و ال Joins فوق ال UDF دي. ال SQL بيضطر ينفذ ال UDF الاول قبل ال Groups و ال Joins و ساعتها هتجبره يعمل ال Seek اللي انت عاوزه.

دي حيلة عنيفة تلجالها بس لو لقيته بيعمل كارثه في ال IO. هي بتعقد الدنيا شوية لكن تاثيرها هايل لانها فعلا بتخليه يعمل Seek و ساعتها Where بتاعتك هتقيد الناتج و تخلي السلوك علي حسب رغبتك.

برغم تطور ال Query Optimizer لكن احيانا بنحتاج دا في ال ال Query بالغة التعقيد.

</p>
</details>

---

اقولك حاجه لسه جايه علي بالي حالا.
اقرا المقالات دي. انا كنت كتبتها زمان. فيها مقدمه لموضوع Locking and Concurrency for SQL.
مرتبه و متدرجه.
افتح بيها شهيتك كده. مسح زور يعني.و لو بتشتغل اوراكل او MySQL برضه اقراها وحقك محفوظ في الفيديوز قريبا

1- [لو سعادتك بتكتب برامج بتتعامل مع RDMBS](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid034gJB8jdq3mf8GwvTiPqmtw9XhFDdWUqN9hzzVUuvgRUz4qANVe3kd5BGjkN6f6pal)

<details>
<p>
لو سعادتك بتكتب برامج بتتعامل مع RDMBS و عندك في الجداول بتاعتك عشرات الملايين من الريكوردز و مئات من المستخدمين سويا  كمل قرايه. لو معندكش الحجم دا من الداتا او العدد دا من الاستخدام المتزامن يبقي متعذبش نفسك واستناني يوم الاحد هرجع تاني لمحاربة الاسباجني.
موضوع ال  Concurrency Control اساسي علشان تعمل الانظمة دي بنجاح.
ايوه اعمل ايه وايه المطلوب ؟
سلوك النظام بيتوقف بشكل رئيسي علي حاجةاسمها Isolation Level ودا اللي لازم حضرتك تختاره بعنايه و بعدين تكتب الكود بتاعك بما يتلاءم مع ال Isolation Level اللي سعادتك اخترته.
بس انا بقالي سنين بشتغل وزي الفل و مغيرتش البتاع اللي انت بتقوله دا و زي الفل.غالبا هتلاقيك اتعرضت لمتاعب و عالجتها بشكل ما لكن لو عندك حجم داتا كبير و عدد كبير من المستخدمين المتزامنين كانت المتاعب هتبقي عنيفة و المعالجات ال Add hock كانت هتتلف الاداء.
يعني انا مطلوب مني اختار ال Isolation Level و بعدين اكتب الكود بما يتلاءم معاه و بكده ابقي شغال صح ؟؟؟  ايوه يا باشمهندس بالظبط كده.
كلمة انك تكتب الكود بما يتلاءم مع Isolation Level مخيفة شوية انا عارف بس اوعدك هتتضح جدا.
و دا يستلزم فهم لمجموعة من الكونسبتس و التحقق من انهم واضحين جدا و دا اللي هحاول اعمله في اكتر من بوست .
سلام مؤقت.
</p>
</details>

2- [القصة هتمشي كالتالي](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid0kFErtoo4qDkhaW1TNy1ossL6hmuUVkGmYiNnvdRhb9kUyK1aRVYHhAZdicHq1hgal)

<details>

<p>
القصة هتمشي كالتالي
Optimistic vs Pessimistic concurrency
Isolation levels for Pessimistic Concurrency(Read Committed,Repeatable Read,Serializable,Read Uncommitted)
Isolation Levels for Optimistic concurrency(Read committed snapshot, snapshot isolation)
Making Selection based on business case(optimistic or pessimistic and which isolation level)
How to take the isolation level effect on your Data Access layer.
</p>

</details>

3- [قهوتك بقي و Give me your full attention.](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid016oLk7SN1fHNWWeywAKmmkWgWweRg3WjdY8jCKQcpEyL3kp7KY45MuzqUEe48Ne5l)

<details>

<p>
قهوتك بقي و Give me your full attention.
Optimistic vs Pessimistic concurrency  part 1 of 2
دا البوست الاول في موضوع ال SQL Concurrency and IsolationLevel و عاوز اوضح انه موضوع مش بسيط و علشان كده هتلاقي كتير من الجمل الاعتراضبه اللي هدفها توضيح مصطلح و التاكد من ان معناه مش  محل رؤية ضبابيه تضر بالسياق.كمان عاوز اطلب منك حاجه, لو سمحت اقرا البوست اكتر من مره علشان تتاكد انك فهمته كويس.انا بحاول اعصر كتاب حوالي 190 صفحة في تلات بوست بما لا يتجاوز صفحتين ودا هيسبب بعض الجهد في القراءة.
تعريفات وكلمتين في الميكانيكا.
يعني ايه Lock ؟ من وجهة نظرنا في هذا العرض فان Lock هوعبارة عن Staus ملحقة بالريكورد في الترانزاكشن. يعني لو الريكورددا بيستخدمه تلاته ولا اربعه ترانزاكشن هتلاقي عليه تلاته ولا اربعه Lock.
الريكورد الواحدممكن يكون عليه اكتر من Lock ؟
ايوه و ارجوك خليك فاكر الجمله دي. ان لو عندك خمسه ترانزاكشن بيستخدموا الريكورد هتلاقي عليه خمسه Lock.
هل اللوك دا له انواع  ؟ ايوه له حوالي 22 نوع(دول اللي انا عارفهم في SQL server) و منهم انواع شائعة الاستخدام هقولك علي اكتر تلاته
النوع الاول اسمه S Shared ودا بيحصل لما تيجي تعمل Select.ايوه ال Select بتعمل Lock و برضه خليك فاكر الجمله دي اوي.
النوع الاني اسمه U Update Lock ودا بيحصل لما حضرتك بتنفذ جمله Update لمجموعه ريكورد او حتي رييكورد واحد و بيكون في الوقت اللي السرفر بيعلم الريكوردز قبل مينفذ الجملة فعليا يعني في مرحله انه يحدد الريكوردعلي حسب جمله where اللي في update statement و يحط عليها U.(الحته دي لسه فيها كلام وهرجعلها في حلقات بتاعه Deadlock متقلقش)
النوع التالت X Exclusive Lock ودا بيستخدم مع Delete , Insert وكمان مع Update بعد ما السرفر يحط ال U بيقلبها X.
دول انواع اللوك. ناخد سيناريو علشان نفهم دورهم والميكانيكس بتاعتهم.
عندنا User أسمه U1 فتح ترانزاكشن T1 و عمل جمله Select علي جدول A1. مجموعة الريكوردز اللي اختارها الراجلدا السرفر هيحط عليها S Lock.(الكلام دا فنيا محتاج توضيحات اعمق لكن لغرض توضيح الميكانيكا هوصحيح  ومناسب)
و عندنا User أسمه U2 فتح ترانزاكشن T2 و عمل جمله Select علي جدول A1. مجموعة الريكوردز اللي اختارها الراجل دا السرفر هيحط عليها S Lock.
دا معناه ان مجموعة الريكوردز دي بقي كل ريكورد منها عليه اتنين Lock و الاتنين نوعهم S.
هنا بقي فيه مفهوم مهم جداااااا. فيه انوع Locks ممكن تتحطمع بعض وانواع لا.
يعني ممكن تحط S مع  S
ممكن تحط S مع U
لكن مش ممكن تحط S مع X
مش ممكن نحط X مع X
مش ممكن تحط U مع U
اللي انا قلته دا اسمه Lock Compatibility.دا كونسبت مهموهيجي فيه كلام كتير ودا  من اعمدة موضوع ال Concurrency عموما.
نرجع للسيناريو بتاعنا. U1 و U2 تمكنوا يعملوا Select لان ال Select بتحط S و ينفع تحط S مع S. وبعدها  U2 بعت جملة Update و كان U1 لسه ال S بتاعه موجود علي الريكوردز فبرضه مغيش اشكال لان U2 هيعمل Lock نوعه U و دا متوافق مع S زي مقلنا من شوية يعني ممكنيتحطعلي نفس الريكورد U و معاها S.
و بعد محط ال U لازم بقي يحولها ل X علشان يكتب ال Update بتاعه. وهنا بقي نقف شوية. هل ال X متوافقه مع ال S اللي لسه حاططها U1 ؟؟؟؟؟
لا طبعا ال X غير متوافقهمع ال S و هنا ال SQL server هيقول ل U2 استني شوية لما ال S تخلص و U1 يخلص T1 و بعدين احطلك ال X بتاعتك. وهودا يا شباب اللي اسمه ال Blocking.ارجوك اقرا الجملة اللي فاتت مرتين تلاته. ال Blocking هو حاله من الانتظار يدخل فيها الترانزاكشن نتيجه لانه يحتاج لوضع Lock غير متوافق علي ريكورد او اكتر.اوعي تنسي بقي ال Blocking.
و الله العظيم و الله العظيم والله العظيم دا اسمه Blocking و دا مش Deadlock خالص مالص بالص.
الBlocking حاجه مختلفه عن ال Deadlock لاني بلاقي الناس بتستخدم كلمه Deadlock عمال علي بطال.
يبقي احنا كده عرفنا التالي :
اللوك انواع
الريكورد الواحد ممكن يكون عليه اكتر من لوك
اللوكس بينها توافق فبعضها متوافق ممكن يتحط مع بعضه علي نفس الريكورد و بعضها لا
لو منفعش يتحط اللوكس مع بعض يبقي الترانزاكشن اللي طالب هيستني لحد اللوك غير المتوافق ميتشال و يخلص شغله وبعدين يحطهو اللوك بتاعه ودا اسمه Blocking.
و دا كان الجزء الاول من البوست الاول.
حاطط صورة ل Lock Compatibility matrix.
زي مقلت ان انواع اللوكس 22 هوهنا بيتكلم عن 7 منهم وانا شرحت تلاته.لوعاوز تقرا ال 22 فهتلاقيهم في msdn.
</p>

![img](/imgs/db/1.jpg)

</details>

4- [نكمل كلام
Optimistic vs Pessimistic concurrency part 2 of 2](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid02p2Cqww92nP9kW7Z6mbuUaSDRQbicqFFhpunhimgPNVCo3SZ85skGJBmDtKqfVwFtl)

<details>

<p>
نكمل كلام
Optimistic vs Pessimistic concurrency part 2 of 2
علشان نعرف نقارن بين Optimistic Concurrency and Pessimistic Cocurreny محتاجين بقي نعرف ايه المقصود بال Concurrency بالظبط.
التعريف بتاعها موجود في كل حته و اسمحلي بقي انا مش ناوي انسخه.
لوالداتابيز بتخدم مستخدم واحد بس مكنش هيبقي فيه اشكال من اساسه. المشاكل بتحصل لما يستخدمها اكتر من مستخدم و الكلام اللي هقوله بيخص بنسة 90% عمليات ال Update لانها اصل الشرور كلها.طبعا ال Insert and delete فيها كلام لكن تعالي نحصر حديثنا في حيز الكلام عن ال Concurrency وكاننا معنيين بال Updates.
لو عندنا ريكورد واحد من المستخدمين فتح ترانزاكشن وعمله Update و لسه مقفلش الترانزاكشن يبقي الريكورد دا بيمر بمرحله انتقاليه و ايه الموقف بقي لو مستخدم تاني كان بيحاول يقرا الريكورد دا او حتي بيحاول هو كمان يعمله Update يبقي ايه اللي يحصل. مين يكسب و ازاي نحدد مين يكسب و كيف تتزامن القراءه مع Update.
اهي القضايا دي بقي هي اللي بيسموها Concurrency.
واضح ان المساله هي مساله تنسيق ل Resource بين اتنين Threads.
ايوه هي كده بالظبط كل اللي بيدور حواليه الموضوع هوالجمله اللي فاتت و انت قريتها دي. ال Resource هو الريكورد و طبعا كل ترانزاكشن هو ال Thread.
فيه اتجاهين للتعامل مع المساله دي:
الاتجاه الاول بيقول اننا نعمل Lock للريكورد و بالتالي اي ترانزاكشن تاني يحاول يوصله لازم ينسق مع الترانزاكش الاول من خلال ال Lock و دا طبعا بتحكمه قواعد ال Lock Compatibility اللي انا حكيتها لسعادتك البوست اللي فات. الاتجاه دا اسمه Pessimistic لانه متشائم و بيفترض ان اي اشتراك في الريكورد هيؤدي في النهايه الي write conflict وبالتالي بيسعي الي منعه من الاول بانه يحط Lock.
الاتجاه التاني مش بيستعمل Lock و كل اللي بيعمله انه لما يقرا ريكورد بيحتفظ بمعرف يتبين منه ان الريكورد متغيرش و دا غالبا بيكون timestamp  و بيسموها هنا Version number ولما يجي يعمل Update يبقي يقارن المعرف علشان يتاكد انه متغيرش. النوع دا متفائل optimistic و بيفترض ان عمليات الكتابه لن تتصادم بكثرة وبالتالي حاجتنا الي Rollback هتكون مش كبيرة و بالتالي مفيش داعي نعمل Locks مكلفة من الاول.
يعني الاتجاهين احدهم بيتبني Locking و الاخر بيتبني Versioning.
ال Optimistic and pessimistic دي لها درجات في التفاؤل و التشاؤم و هي دي اللي بيسموها Isolation Levels.
لو وصلت للنقطه دي و كنت متابع كويس وفاهم اهنيك انت قطعت 30% من مشوار عنيف قله قليله عارفاه و اقل من القليل اللي فاهمه كويس.
انا بتحرك في شرح الموضوع ببطئ و غالبا هحتاج اكتر من يوم. اظن المعدل دا مناسب حتي لواخد وقت اطول.
</p>

</details>

5- [نبدا نستعمل المعلومات اللي كوناها عن Locking ](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid0EroEu1HZcJh3vUf9tW2qUpsu2aQ2jZM6g3iBU2pMu2MwwcUsw8wW5ST8Jk2dZ6Tal)

<details>

<p>
نبدا نستعمل المعلومات اللي كوناها عن Locking وعن ال Concurrency عموما.
البوست دا بيتكلم عن Pessimistic Concurrency و دي اللي السرفر بيحقق فيها ال Concurrency عن طرق Locking.
شوف يا سيدي ال SQL اساسا بيعتمد علي Locking علشان يحقق ال Concurrency يعني سلوكه Pessimistic by Default.وانا الحلقة اللي فاتت قلت لحضرتك ان ال Isolation level هوبمثابة درجة التشاؤم.و لما انا قلت كده انا شفت علي وشك نظرة تساؤل و غضب و سمعتك وانت بتقول "هو بيكروت في الكلام ليه ؟" متزعلش انا عامل حسابي علي كل حاجه.
تعالي ناخد سيناريو و نشرح فيه الميكانيكا.
1-user u1 open transaction t1
2-u1 select record r1 from table a1
3-user u2 open transaction t2
4-u2 update record r1 in table a1
تعالي بقي نشوف ايه اللي حصل جوه دماغ ال SQL. في خطوة 2 السرفر هيحط S Lock علي r1
في خطوة 4 السرفر هيحط U علي r1 و بعدين يحاول يحول ال Lock من U الي X
تفتكر هيعرف ولا مش هيعرف ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟
لو كان الريكورد لسه عليه S مصدرها u1 يبقي مش هيعرف لان Compatibility بتنمع S with X انما لو كان ال S خلص يبقي هيعرف.
مين اللي بيحدد اذا كانت S هتفضل و لا تتشال لما ال Select تخلص . مين اللي بيحدد  Life span of the lock ؟؟؟ انه ال Isolation level يا اخي العزيز.
لو كان الisolation level هو read committed و دا هو ال Default هتلاقي ال S بتتشال بعد ال Select متخلص علي طول و ساعتها كان ال update هيعرف يحط ال X بتاعته انما لو كان isolation level اعلي من Read committed يعني مثلا repeatable read or serializable كان ال S هتفضل موجوده لحد الترانزاكشن t1 ميخلص و ساعتها كان u2 هيحصله Blocking.
يعني لو استخدمنا read committed في t1 مكنش هيحصل Blocking ل t2 بس كان هيبقي فيه مخاطر ان r1 اللي قراه u1 هيتغير بعد  مقراه.
انما بقي لواستخدمنا repeatable read or serializable كان r1 مش هيتغير بعد مقراه u1 لان ال S كانت هتفضل موجوده و كان هيحصل عدم توافق بين S and X لما u2 يحاول ينفذ ال update  بالتالي u2 كان هيبقي blocked.
ال isolation level هو اللي غير السلوك بانه بيغير زمن ال Locking و يخلي السرفر يشيل اللوك اويسيبه لحد الترانزاكشن اللي فتحه ميخلص و بيه تقدر تقلل فرص حدوث blocking و تجازف بتغير الريكورد بعد قراءته  أو تتحمل ال blocking  و في المقابل تقلل درجة Concurrency بتاعة النظام.
اقرا البوست دا اكتر من مره. لو فهمته يبقي مبروك سعادتك بقيت عارف ايه تأثير تغيير ال isolation level  في دماغ السرفر و دا معناه انك هتعاني كل مره تكتب Query لانك هتبقي شايف تبعاتها.
الموضوع محتاج اني اكمل امثله تانيه  قبل مكمل شرح.
الي حلقة قادمة.
</p>

</details>

6- [نستكمل SQL Concurrency and Locking Architecture](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid02JabWR26xo1hAD5D3J5JZmP3n9e12rtnuG3gbZc1tVStvJr9HzB9iLdEUxu3fPMWPl)

<details>

<p>
نستكمل SQL Concurrency and Locking Architecture
الامور بدات تتضح بشكل كويس ودا هيشجعني اضيف كونسبت جديد لحضراتكم لانه هيساعدني في البوستات الجاية و في الامثله الاكثر تعقيدا عندما نتناول ال Isolation levels بعمق اكبر.
الكونسبت دا اسمه Lock Escalation.
حاليا سعادتك عارف ان ال Lock هوعباره عن Staus ملحقة بالريكورد في الترانزاكشن.  وان ممكن يكون فيه اكتر من Lock علي نفس الريكورد طالما فيه اكتر من ترانزاكشن بيستخدموا نفس الريكورد.
السرفر اللي هويعني ال SQL بيشيل ال Lock دا في الذاكرة بتاعته وهو شغال. تخيل معايا بقي لوفيه Query عنيفة احناجت تحط الوف من Locks علي الوف من الريكوردز.
في الحالة دي ال SQL هيعاني من memory Pressure و دا طبعا ممكن يخلي اداؤه ينحدر جدا وعلشان يحمي نفسه بيعمل حاجه اسمها Lock Escalation اللي هي انه يفك الLocks الكتير دي ويستبدلها ب Lock واحد علي ال Table كله.
ينهار ابيض. يعني يعمل Lock علي الجدول كله ؟؟؟؟؟
ايوه يا بيه.
ودا بيكون نتيجته طبعا انه يزود احتماليه  ال Blocking علي باقي الترانزاكشنز اللي بتستخدم الجدول اللي حصل عليه Lock Escalation.
 تقدر حضرتك تشوف ال Escalation دا في ال SQL profiler بتاعك.
الكلام اللي انا قلنه هنا دا محتاج مزيد من التوضيح علشان يبقي صحيح 100% لكن كده حضرتك عرفت يعني ايه Escalation و مدي خطورته علي ال Blocking و طبعا زياده احتمالات ال Blocking هتزود احتملات ال Deadlock كما سيجئ في حلقات قادمه.
ال Lock Escalation لما تلاقيه بيحصل و تشوفه بيجي في Profiler علامه علي ان عندك Queries  بتسبب Locks كتير ودا ممكن يكون لانها محتاجه Tuning اومحتاج تضيف Index علشان تعمل Seek بدل Scan او علامه علي الاتنين مع بعض.
دا كونسبت مهم هنحتاجه في حلقات قادمه.انا كنت ناوي اعمل بوست اطول من كده لكن متاسف مجهد شويه ومش عاوزاكتب كلام مش واضح يتعبكم.
</p>

</details>

7- [نستكمل SQL Concurrency and Locking Architecture](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid0MYiGct73BECWUJj4u2GFvXymb1rniKESLTEd6JnAYrrh8qD6YqiLUJkwfintqqWel)

<details>

<p>
نستكمل SQL Concurrency and Locking Architecture
البوست دا هيكمل موضوع pessimistic Concurrency و هنا هنستخدم كل المفاهيم اللي بنيناها في الست بوستات السابقين علشان نشرح ال Isolation Levels المختلفه اللي تخص pessimistic.
المصفوفه اللي مع البوست دا (الصورة) فيها مستطيل اسود بخط سميك. دا اللي يخص Pessimistic Isolation و بنهايه البوست دا لازم حضرتك تكون فاهم معني كل الخلايا اللي في المستطيل السود
 في بوست سابق استخدمت مثال علشان اوضح دور ال Isolation Level و قلت انه بيحكم life cycle بتاعه ال Lock. في الحقيقه يا شباب هو اكبر من كده وهو مفهوم اكثر تجرد من Life Cycle بس مكنش ينفع اقولك كده ساعتها لانك كنت هترتبك و متقدرش تكمل متابعه.في الوقت الحالي انا هشرح ال Isolation Level بشكل اعمق شويه و بعدين هشرح المصفوفه اللي في الصورة.
اشتراك اكتر من مستخدم في نفس قاعدة البيلنات بيسبب Concurrency issues و العلماء اللي حطوا الستاندرد حللوا المشاكل دي و قالوا ان ال Concurrency issues هي في الحقيقه ليست الا حدوث لاي من ثلاث ظواهر او تجميعه منهم وهذه الظواهر هي :
Dirty Read
Non Repeatable Read
Phantom
و دور ال Isolation Levels المختلفه انها تحمينا من هذه الظواهر. طبعا كل ميعلي ال Level تزيد درجة الحماية و نوصل لمنع تام لكل هذه الظواهر.
الظواهر المصاحبة لل Concurrency :
اول ظاهرة هي Dirty reads و هي ببساطه ان الترانزاكشن يقدر يقرا داتا لسه الترانزاكشن اللي بيكتبها معملش commit لها و دا موضوع بسيط زي منشوف.
تاني ظاهرة وهي non repeatable reads ودي بقي اصعب شويه. وفيها الترانزاكشن يقرا داتا و يكمل شغل و لو جه يقراها بعد شويه يلاقيها Updated يعني ميقدرش يعمل repeated read لنفس الداتا و يلاقيها بنفس القيمه. ودا طبعا لانه موفرلهاش حمايه و لوكان وفرلها حمايه Lock يعني مكنش ترانزاكشن تاني قدر يغيرها.
تالت و اخر ظاهره Phantom و دي اصعب شويه. اللي بيحصل ان الترانزاكشن بيقرا مجموعه ريكوردز طبقا ل Criteria معينه زي مثلا انك تكتب Select * from employees where where departement =3 , هنا ال Query هتجيبلك كل الموظفين اللي في departement 3. و بعدها الترانزاكش يكمل شغل و يرجع يعمل نفس ال Select يقوم يجيله ريكوردز عددها اكبر من المره الاولي. دا بيكون سببه ان ترانزاكشن تاني كتب ريكورد في الجدول و كان حقل ال departement=3 فبالتالي الريكورد الجديد طلع مع الترانزاكشن الاولاني في Select بتاعته  و بيسموا الريكوردز الزياده دي Phantom يعني شبح.
كيفية تغامل كل Isolation Level مع ظواهر ال Concurrency:
معالجة الظاهرة الاولي Dirty Reads. ببساطه جميع ال Levels ما عدا Read Uncommitted مش بتقرا اي ريكورد عليه X يبقي بالتالي اي ريكورد بيمر بعمليه Insert or update or delete مش هيقراه الترانزاكشن الا بعد commit علشان يشوفه.و بيحصل دا ازاي يعني ؟ بيحصل ببساطه ان اي ترانزاكشن علشان يقرا لازم يحط S و حيث ان ال S مش متوافق مع X فبالتالي مش هيعرف يقرا Dirty read لان لسه عليه X.
ال Level بتاع Read uncommitted هو الوحيد اللي مش بيحاول يحط S اثناء القراءة و بالتالي بيقدر يقرا ال X و فيه ناس بتسميه nolock علشان مبيحاولش يحط S lock اثناء القراءة.
نروح بقي للظاهرة التانيه non repeatable reads و علشان ال Isolation Level يحققها لازم يحمي الريكورد من ان تتغير اول ميقراها.يعني الترانزاكشن  كل ميقرا ريكورد يسيب ال S عليه ميشيلهاش الا في نهاية التانزاكشن علشان محدش يقدر يحط عليه X و يغيره.الل Levels اللي بتعمل كده هي Repeatable read and serializable لكن ال Read committed بتشيل ال S فورا.
دا معناه ان repeatable  read and serializable بتسيب ال lock فتره اطول وطبعا دا بيعمل Blocking لباقي الترانواكشن اللي بتحاول تكتب علي نفس الريكوردز.
بص علي المصفوفه كده. هتلاقي non repeatable read معموله no في حاله repeatable read and serializable و دا لانهم بيمنعوه بحكم انهم بيسيبوا ال S بتاعتهم لحد اخر الترانواكشن.
الظاهرة التالته و الاخيره ال Phantom.ازاي فيه Level ممكن يمنعها.لوحضرتك فكرت في وضع ال S علي الريكورد لحد اخر الترانواكشن هتلاقيه بيحل non repeatable read لكن ازاي هيمنع رؤية ريكورد مكنش موجود ساعة محط ال S ؟
دا بقي خاصية مميزة جدا لاخر نوع من Isolation اللي هو Serializable انه مش بيحط ال Lock علي ريكوردز بعينها. لا دا بيحط ال Lock علي Range.
يعني ايه  ؟؟؟؟؟؟؟؟؟؟؟
يعني بيحط ال Lock علي كل الريكوردز اللي تشملها ال Select بتاعته يعني في حاله المثال بتاعنا هيحط ال S علي اي ريكورد اتكتب او  يتكتب و فيه department=3 و بيسموه Range lock. و طبعا بيسيبه لحدالترانزاكشن ميخلص.
ايوه Range Lock اقراها كذا مره كده.
لو سعادتك فاهم لحد هنا يبقي انا عاوز اهنيك و الله. حضرتك كده فهمت ال pessimistic concurrency .
البوست الجاي هنبدا في optimistic concurrency و هو اتنين Level. و واجب علي اقولك انك لوبصيت في الماتريكس هتلاحظ ان Serializable مطابق تماما ل Snapshot isolation.
الحقيقه الماتريكس بتقول كده فعلا و دي للاسف خدعه سببها ان الستاندرد وقع في غلطه عنيفه.
انت بتشتم الستاندرد ؟؟؟؟؟؟؟؟؟؟؟؟
ايوه ولما نخلص ال optimistic و نفهم ال snapshot هتغرف ليه و هقولك ان الماتريكس دي مضلله في نقطه معينه و هجيبلك ادله علي كلامي.
يعني ال serializable is not equal to snapshot.
و خليك فاكر الكلام دا لان ناس كتير غلطت وحولت الي snapshot علشان تستفيد بسرعته وراحوا في داهيه.
</p>

![img2](/imgs/db/2.jpg)

</details>

9- [عندي تصور ان موضوع ال SQL Concurrency and Locking Architecture](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid0qJoBJpAN8SBi3ygACUVyBVUYzrRhnj73Pb9UKU5suJm3oFzHBWww7nfQ8cxgPPNTl)

<details>

<p>
عندي تصور ان موضوع ال SQL Concurrency and Locking Architecture قطعنا فيه شوط كويس لحد دلوقتي. موضوع pessimistic Concurrency خلص (الي حد ما . انا لسه عندي فيه كلام كتير اوي بس مش وقته) و مفروض نكمل.
الدور علي ال optimistic Concurrency.
خطتي لشرح   optimistic Concurrency  هي اني ارجع بحضرتك لسنه 2003 و ادخلك تحضر اجتماع بين اتنين من الاركتكتس اللي بنوا ال Concurrency Model و طبقوا الستاندر بتاع Pessimistic Concurrency و اخليك تسمعهم وهما بيفيموا اداء النظام ومميزات و عيوبه وتشوفهم ليه فكروا في ال Optimistic Concurrency من اساسه.
انا بحضر الحوار اللي دار بينهم و هرتبه و اجيبهولكم بكره.
برجاء تراجع المثال اللي انا حاطط الصورة بتاعته هنا لان الاتنين الاركتكس دول هيبداوا حديثهم بخناقه بسببه.
علي فكره لو مش فاهم المثال يبقي فيه اشكال  ولازم نستوضح الغوامض.اكتب اسئلتك في الكومنتس.
ابقوا معنا.
</p>
![img3](/imgs/db/3.jpg)

</details>

10- [الدور علي ال Optimistic Concurrency part 1/2](https://www.facebook.com/mohamed.hamedhammad/posts/pfbid031qHDiWENHLzHQizgHkk8ybsnpZ3YtFdg56RpPgGnXAZwX6KSQzNxYXte41mzYo9Ul)

<details>

<p>
الدور علي ال Optimistic Concurrency part 1/2
خطتي لشرح   Optimistic Concurrency  هي اني ارجع بحضرتك لسنه 2003 و ادخلك تحضر اجتماع بين اتنين من الاركتكتس اللي بنوا ال Concurrency Model و طبقوا الستاندر بتاع Pessimistic Concurrency و اخليك تسمعهم وهما بيقيموا اداء النظام ومميزات و عيوبه وتشوفهم ليه فكروا في ال Optimistic Concurrency من اساسه.
اختيار ديالوج بين اتنين هدفه توضيح مميزات وعيوب ومحاوله الوصول لافضل حل للمشاكل. الاتنين الاركتكس دول س و ص.
هنا س معجب جدا بال Locking و ص  شايف عيوب و مش مبسوط و الاتنين عندهم feedback من المهندسين اللي استخدموا ال Pessimistic Locking و برضه بيناقشوه ويفكروا فيه.
انا هعمل فواصل اعتراضيه اوضح فيها كلامهم علشان احيانا بيكون مش مباشر اوي في المعني.
س- التعامل مع ال anomalies اللي الستاندرد حددها وهي dirty read, non repeatable reads and phantom فعلا غطي كل احتياجات  concurrency اللي النظام محتاجها ومفيش حد عنده حاله مش قادر يغطيها.
ص- دا حصل لكن بتكلفه عاليه جدا حتي ال read committed اللي هو اقل level في ال Isolation بيسبب سلوك مش مقبول عند بعض الناس.
س- اي عمليات Locking لازم هتلاقي فيها Reads blocks writers,Writers blocks reads و دا مطلوب و امان علشان النظام.
حماد-المقصود  من الجمله ان في حاله read Committed بيحصل ان جمل Update بتمنع القراءه (طبعا لحد الترانزاكشن اللي بيكتب يخلص و يشيل ال X)ودا بيسموه writer block reader و في حاله ال Repeatable read , serializable بقي بيحصل ان  writer block reader and reader block writer لان ال S بتفضل عايشه طالما الترانزاكشن مفتوح و بيكون ساعتها reader block writer فرصتها كبيره اوي.
ص- لكن مش مطلوب في كل الحالات وفيه بيزنس سيناريوز كتير دا يعد فيها اهدار للموارد بتاعه السرفر و Blocking مالوش معني.
س- يبقي لازم تفاصيل علشان نقيم الاشكال و الحل.
الباشمهندس ص كان محضر المثال (افتح سعادتك بقي الصورة اللي مع البوست)
ص-خد عندك الحاله دي u2 عمل update لريكوردى واحد و لسه التانزاكشن بتاعه مخلصش و u1 بيحاول يقرا اكتر من ريكورد يعني ممكن يكون بيحاول يقرا الف ريكورد مثلا لكن منهم ريكوردواحد اللي هو u2 بيعمله update. اهو هنا قرايه الريكوردز دي حتي لوكانت الف هتبقي blocked لحد update متخلص.
س- ما هو دا طبيعي و الا u1 هيقرا dirty read.
ص- انا مقلتش يقرا الداتا من غير متكون commited.
س- امال قلت ايه ؟
ص- قلت انه يقرا الداتا بتاعة الريكورد دا قبل متبدا عمليه ال update و كانه بيقرا "نسخه قديم" منها وحيث انه بيقرا الف ريكورد فبالتالي مش شرط يكون ناوي يغير الريكورد دا بالتحديد و يا سيدي لو هيغيره و يبعت update يبقي النظام يرفض و يقوله ان الريكورد اتغير بالفعل(عن طريق u2 يعني)
س-نسخه ايه اللي عاوزه يقراها. الداتا في ال cluster index وعليها X. يعني ايه "نسخد قديمه"؟؟؟؟؟؟؟
ص-قصدي ان اي حدهيعمل تغيير في داتا ال SQL ياخد الداتا قبل التغيير و يحطها في مكان ما. واي حد يعمل قرايه و يحتاج فيها الداتا دي يجيبها من هناك. و اول الكتابه متخلص نشيل النسخه القديمه دي و يا دار مدخلك شر.
س-يعني يبقي عندنا نسختين من الداتا . واحده قديمه وواحده بيحصلها نعديل ؟
ص-ايوه و بكده اللي عاوز يقرا ميستناش اللي عاوز يكتب ومنوقفش Query هتقرا الف و لا الفين ريكورد علشان ريكورد بيحصله Update.
س-و الله يعني (بيهرش في الصلعه . ايوه اصلع برضه) كلامك معقول بس دا مش Locking دا كده Versions من نفس الريكورد.
ص- و ماله هو يعني ال Locking دا نزل من السما !!!!!
س- طيب افرض بقي حبكت مع u1 و حاول يعدل في نفس الريكورد اللي هو قراه من ال version القديمه ؟
ص- ياسيدي ساعتها نديله رساله update conflict و نبقي سيبناه يقراه الوف الريكوردز و يشتغل عليها و الاحتماليه الضعيفه دي انه يعدله نحلها ب Conflict Detection.
حماد- و هنا يا شباب اتولدت فكره ات الداتا بدل منحط عليها locks تعطل وتعمل Block لكل الدنيا لا ننسخ منها Versions و نخلي الناس تقراها ونسيب الريكورد الاصلي يتعدل في مكانه و محدش يوقف حد.
لسه فيه كلام بس هو دا الكونسبت الاساسي بتاع ال Optimistic Locking.
عرفت ليه اسمه "متفائل" لانه بيفترض ان مش كل Read اكيد هيعقبها update ممكن اقرا الوف الريكورد و اعدل منهم عشره و مش شرط يعني يكون واحد منهم هو اللي بيحصله update بحد تاني في نفس اللحظه.
استبدلنا ال locks المكلفه ب Versioning+conflict detection و بكده المثال اللي عندك هنا في الصوره مش هيحصل فيه ان writer block reader.
و هنكمل كلام لان الموضوع بتاع Optimistic لسه مخلصش.
في الاخر هتعرف ان Optimistic له عيب و ال Pessimistic برضه له عيب(غير الاداء يعني) و لسه البشر ملقوش الحل الكامل للمشكله.
ابقوا معنا.
</p>
![img4](/imgs/db/4.jpg)

</details>

---

<details>

<summary>
لو عندك داتابيز فيها جدولين، customers, orders...
</summary>
<p>
لو عندك داتابيز فيها جدولين، customers, orders و بينهم relation تربط ال جدولين علي customer ID ، انت اكيد شفت المثال دا مليون مرة.
لو عندنا view بيجيب الداتا من ال جدولين دول باستعمال relation طبعا، لو انت بقي ال SQL سرفر، هتروح علي آل orders و بعدين تجيب ال customer المناظر ؟ و لا تروح علي ال customers و تجيب الا orders المناظره، أثناء التنفيذ يعني. و لا متفرقش ؟
خرابيش في مخ ال SQL و مخك.
لو لقيت السؤال محير يبقي مبروك، انت كده بدأت تشوف التعقيدات بتاعة الداتابيز اللي فعلا بتميز الناس عن بعض.
</p>

</details>

<details>

<summary>
لوحضرتك قريت عن SQL Window Functions...

</summary>
<p>
لوحضرتك قريت عن SQL Window Functions و شفت ازاي تعمل Lag, Lead, Offset والحلويات الي تخليك تعمل Logic معقرب تجيب بيه الداتا في كلمتين. تسمح بقي تقولي هتعمل الكلامدا في EF ازاي بنفس السهوله.
مفيش بديل عن تعلم كتابه SQL كويس.
الاجيال اللي بدات حياتها مع EF بيقاوموا الفكره دي جدا. 
وكمان التيم ليدرز و السينيورز اللي مش بيذاكروا ومعلوماتهم عن ال SQL وقفت عند SQL 2000 برضه بيجدوا ال EF حل مقبول و بيحبوه لانهم ببساطه مش عارفين ايه اللي ممكن ال SQL يعمله اكتر من Select و Correlated Queries و الاسباجتي المعتبر.
اتعلم SQL كويس لان فايتك كتير. هتكتب SQL قليل وهيبقي مقروء و غالبا هيكون افضل من ال Stored Procedure اللي مدفون في جثه 500 سطر و ريحة العفونه طالعه منها علي بعد كيلو.
ابدا هنا.
</p>

![img5](/imgs/db/5.jpg)

</details>

<details>

<summary>
دا كلام يهم كل الناس علي اختلاف خبراتهم من جونيور...

</summary>
<p>
دا كلام يهم كل الناس علي اختلاف خبراتهم من جونيور صغير لحد تيم ليد كبير.
هتلاقي كتب ال SQL المحترمة بتتكلم عن طريقتين في كتابة ال SQL. الاولي اسمها Row Based والتانية اسمها Set Based.
في اكتر من بوست كنت اتكلمت في الموضوع دا برضه. وعاوزاكمل كلام.
ايه اهمية المساله دي ؟
ال SQL بينفذ Set Based اسرع بكتير جدا لانهم متصمم علشان كده.
وضحلي شوية بقي. حاضر.
لو عند حضرتك جدول في مبيعات تمت لعميل عبر الاشهر المختلفة وعاوزين نطلع الداتا بحيث جنب كل عميل نجيب مبيعات الشهلر و معاها تغير المبيعات عن الشهر القادم و كمان نجيب تغير المبيعات عن الشهر بعد القدادم و بجوارهم برضه  نسبةمبيعات هذا الشهر نسبة الي الاجمالي في العام.
المطلوب دا رزل وهتلاقي ناس كتير هيفكروا يعملوا Loop وجواه كود بيقرا الداتا ويرتبها بالشكل المطلوب و ممكن يعملول Cursor برضه  تعمل اللعبة دي.
التفكير دا اسمه Row Based لانك حولت المساله الي Rows بتجيبها وتعمل عليها حساباتك وترتبها في صورة Tabular علشان ترجعها لكن طبيعة ال Fetch دا يبيكون Row Row و دا وحش جدا جدا جدا في الاداء و الصيانه بتاعة الكود كمان لانه بيتعقد ويبقي جحيم.
ال SQL كلغة بيتطور علشان يساعدك تتجنب الحلول دي و يديلك حلول Set Based ومن ضمن الحلول دي حاجة اسمها Window Functions ودي بتخليك تتحرك علي الداتا راسيا و انت بتنفذ جملة Select تقدر تقرا داتا من Row تاني في نفس ال Frame.
وال Frame هو عبارة عن تقسيم Logical كان الجدول بقي Windows و بتتحرك عليها راسيا بشكل Logical في نفس SQL Statement و تجيب داتا "مجاورة" لل Row الحالي.
دا بيديلك فرصه تعمل جمل Select تشتغل Set Based و توصل بيها للنواتج بتاعتك.
ال Window Function مش هي الطريقة الوحيدة علشان تشتغل Set Based  لكن دي مباشرةجدا وسهلةجدا. التكنيكس هنا كتير اوي.
رغبتي من البوست اني انبهك. لولقيت نفسك بتعمل Loops جوه ال SQL توقف. انت بتعتدي علي هيكلية التصميم الاساية بتاعته وغالبا النتيجة هتكون اداء سئ.
اقرا الجملة اللي فاتت تاني.
المقل بيحكي ال Window Function و بيمر غلي مسالة Set Based vs Row Based.
</p>

- [Window Functions in SQL Server](https://www.red-gate.com/simple-talk/databases/sql-server/learn/window-functions-in-sql-server/)

</details>

<details>

<summary>
هل ممكن Select Statement تسبب Write Operation ؟
</summary>
<p>
هل ممكن Select Statement تسبب Write Operation ؟
الاجابة ايوه. لو ال Query معقده ممكن ال SQL يقرر انه يكتب نواتج جزء من ال Query علشان يعيد استخدامها في جزء اخر من ال Query.
يا نهار ابيض. ودي تعمل ايه ؟ تعمل اداء ممكن يكون مؤلم.
واعرفها ازاي دي بقي ؟
تقرا ال Execution Plan هتلاقي فيها Spool Operator.
و الحل ؟ غالبا هتلاقي ال Query بتشاور علي نفس ال Result Set في مكانين ودا بيحصل مع ال Queries المعقده و اللي حتي الان ال Optimizer مش بيحللها كويس و في الاغلب بيكون دا موجود مع Correlated Sub Queries مكتوبه باهمال.
هكتبلكوا كده كل يومين تلاته عجيبه من عجائب ال SQL.
كل مفتكر حاجه هكتبهالك.
طب متكتبهم مره واحد ؟ مع الاسف مش موجودين مع بعض في نفس البلوك في نافوخي و اللي تنور هكتبهالك.نافوخي من جوه مش مرتب كويس.مليان بقي عفاريت من كل لون و نوع.معذرة يعني
</p>

</details>

<details>

<summary>
بشوف سؤال  كتير و كمان بلاقيه مكتوب علي سبيل الهزار في بوستات تريقه....

</summary>
<p>
بشوف سؤال  كتير و كمان بلاقيه مكتوب علي سبيل الهزار في بوستات تريقه.
ليه شركات معظم شغلها في قواعد بيانات وERP مثلا تلاقيهم بيسالوا المهندسين في الانترفيو في خوارزميات ومسائل صعبه مع ان القصه يعني شويه Business Logic و Data Access Layer والف الف مبروك.
و عاوز اتكلم في السبب يمكن يساعد يوضح الرؤيه.
كتير من الحالات بيكون مطلوب من المهندس يحل مساله في كود مش كويس. يعني كود مش مكتوب حلو. القصه دي بتحتاج قبل اي معلومات في التكنولوجي بتحتاج مهارات تحليليه عاليه. يعني قدرة علي تفتيت المشكله وعزلها في مساحات اضيق للوصول الي Root cause.وبعدها بقي يجي دور الحل اللي المفروض يبقي بمشرط الجراح اللي يعرف هيعدل ايه فين علشان يحل المشكله من غير ميسبب ضرر في اماكن تانيه.
النوع دا من المهارات لا يمكن اختبارها باني اطلب منك تكتب جمله SQL و لا اني اسالك حتي في Design Patterns.
ديمهارات علشان اختبرها هديلك مسائل تحتاج تحليل و قدرات علي عمل Abstraction كويس يحول المساله اللي مليانه Logic معقرب الي صورة اخري يمكن حلها بتصميم واضح و يا ريت كمان يكون بسيط.
الانترفيو العنيف له سبب مش رزاله وخلاص.
ولو كان حقل عملك هيمتد كمان لبناء خوارزميات AI و لا غيره بيكون بالغ الاهميه لان فهم الخوارزميات دي بيحتاج مهارات و قدرات عقليه اعمق و اكثر من حتي عمليات التطوير.
يا رب تكون الامور اتضحت.
</p>

</details>

<details>

<summary>
اللي بيحصل هنا دا Game Changer فعلا في التعامل مع Graph Database.
...
</summary>
<p>
اللي بيحصل هنا دا Game Changer فعلا في التعامل مع Graph Database.
قدرة قاعدة البيانات اللي شايله Graphs علي انها تحقق Horizontal Scalability دا ممكن يخلي ناس كتير كتبت Sharding Mechanism وطلع عينهم سنين ممكن تغير رايها وتلاقي حل مامون. دا طبعا بافتراض ان عمليه Scalability مش متوقفه علي تركيب ال Graph منحيث التعقيد و نسبه Edge Nodes الي Intermediate Nodes.
عندي مليون سؤال بيلفوا في نافوخي عن التصميم الداخلي بتاعها وهدور وراها واشوفهم استندوا الي ابحاث بتقول ايه لان دي قضيه في Distributed Databases بقالها سنين الناس بتعافرفيها.
و باذن الله لما اطمن علي الاسئله اللي في دماغي هكتبلكم ريفيو عميق.
انا هنا بقولك ان ال Feature بتاعه Horizontal scalability لل Graph معلن انها موجوده لكن مش بقولك اني واثق فيها. بصراحه هدور وراها شويه و اشوف المعالجه تمت ازاي لان ال Cross Machine Queries ممكن تكون عنيفه وتخلي الاداء مش كويس الا لو كانوا طوروا خزارزميات ذكيه جدا لل Rebalancing. هتفسح معاهم شويه وارجعلكم بتصور واضح.
</p>

- [Neo4j: Unparalleled Graph Database Scalability Delivered by Neo4j 4.0](https://www.youtube.com/watch?v=soJnVAKQY_o)
</details>

## FP

<details>

<summary>
حتي الان انا التزمت بالاتفاق ان سيشنز ال FP ....

</summary>
<p>
حتي الان انا التزمت بالاتفاق ان سيشنز ال FP هيبقي فيها فقط الحد الادني من النظريات اللازم للتطبيق و كمان قلتلك اني هقولك علي مكان تذاكر منه نظريات اكتر و تفهم الاسس بشكل اعمق.
اللينك دي فيها افضل مصدر بيحقق اتزان في العرض بين النظريه والتطبيق و بيميل للنظريه في بعض الاماكن لكن بيكون عنده سبب قوي.
دا احسنمصدرممكن تزود بيه معلوماتك عن ال FP من ناحيه category Theory و فعلا يكون بيقول كلام مفيد و تقدر تسقطه علي عملك.
دا مش لازم علشان تكمل سيشنز ال FP ابدا. انا ماشي في طريقي و هفضل دايما بعصر ما يلزم من النظري علشان يخدم التطبيق لمن يريد و يحب هذا التوجه. فقط اردت اطلاعك علي مصدر جيد اكثر عمقا.
و ممكن لما اخلص كلامي في FP اعمل سيشن ساعتين اقولك فيها مختصر الكتاب لو عاوزين.
</p>

- [Category Theory for Programmers: The Preface](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/?)

</details>
